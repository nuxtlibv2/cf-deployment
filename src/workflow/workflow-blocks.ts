import { DEFAULT_WORKFLOW_NAME } from './constants'
import type { WorkflowPackageManager, WorkflowTarget } from './types'

// This helper is here to safely place branch names inside GitHub `if:` expressions.
// It escapes single quotes so the expression string stays valid.
// We need this because branch names can contain apostrophes.
function escapeGithubExpressionString(value: string): string {
  return value.replaceAll('\'', '\'\'')
}

// This helper is here to build the workflow header and trigger section.
// It writes workflow name, push trigger, and optional branch filters.
// We need this so branch filtering logic is defined in one place.
export function getWorkflowHeaderBlock(branches: string[]): string {
  const lines = [
    '# Generated by @nuxtlib/deployment-cf-workers',
    `name: ${DEFAULT_WORKFLOW_NAME}`,
    '',
    'on:',
    '  push:',
  ]

  if (branches.length > 0) {
    lines.push('    branches:')
    for (const branch of branches) {
      lines.push(`      - ${branch}`)
    }
  }

  lines.push(
    '',
    'concurrency:',
    '  group: deploy-${{ github.workflow }}-${{ github.ref }}',
    '  cancel-in-progress: true',
    '',
    'jobs:',
    '  deploy:',
    '    runs-on: ubuntu-latest',
    '',
    '    env:',
    '      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}',
    '      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}',
    '',
    '    steps:',
    '      - name: Checkout',
    '        uses: actions/checkout@v4',
  )

  return lines.join('\n')
}

// This helper is here to build package-manager-specific setup/build steps.
// It adds the correct cache, install, and build commands for npm/pnpm/yarn.
// We need this so each package manager generates a valid workflow without duplicated logic.
export function getBuildStepsBlock(
  packageManager: WorkflowPackageManager,
  nodeVersion: string,
): string {
  if (packageManager === 'pnpm') {
    return [
      '      - name: Install pnpm',
      '        uses: pnpm/action-setup@v4',
      '        with:',
      '          version: 10',
      '',
      '      - name: Setup Node',
      '        uses: actions/setup-node@v4',
      '        with:',
      `          node-version: ${nodeVersion}`,
      '          cache: pnpm',
      '          cache-dependency-path: pnpm-lock.yaml',
      '',
      '      - name: Install deps',
      '        run: pnpm install --frozen-lockfile',
      '',
      '      - name: Build Nuxt app',
      '        run: pnpm run build',
    ].join('\n')
  }

  if (packageManager === 'yarn') {
    return [
      '      - name: Setup Node',
      '        uses: actions/setup-node@v4',
      '        with:',
      `          node-version: ${nodeVersion}`,
      '          cache: yarn',
      '          cache-dependency-path: yarn.lock',
      '',
      '      - name: Install deps',
      '        run: yarn install --frozen-lockfile',
      '',
      '      - name: Build Nuxt app',
      '        run: yarn build',
    ].join('\n')
  }

  return [
    '      - name: Setup Node',
    '        uses: actions/setup-node@v4',
    '        with:',
    `          node-version: ${nodeVersion}`,
    '          cache: npm',
    '          cache-dependency-path: package-lock.json',
    '',
    '      - name: Install deps',
    '        run: npm ci',
    '',
    '      - name: Build Nuxt app',
    '        run: npm run build',
  ].join('\n')
}

// This helper is here to map package manager choice to the wrangler deploy command.
// It returns the command prefix used by deploy steps.
// We need this so deploy step generation does not duplicate command logic.
function getDeployCommand(packageManager: WorkflowPackageManager): string {
  if (packageManager === 'pnpm') {
    return 'pnpm dlx wrangler deploy'
  }

  if (packageManager === 'yarn') {
    return 'yarn dlx wrangler deploy'
  }

  return 'npx wrangler deploy'
}

// This helper is here to build deploy steps for one or many targets.
// It emits a single plain deploy when no env targets exist, or conditional env deploys per branch.
// We need this so deploy behavior stays aligned with generated wrangler environments.
export function getDeployStepsBlock(
  packageManager: WorkflowPackageManager,
  targets: WorkflowTarget[],
): string {
  const deployCommand = getDeployCommand(packageManager)

  if (targets.length === 0) {
    return [
      '      - name: Deploy to Cloudflare',
      `        run: ${deployCommand}`,
    ].join('\n')
  }

  return targets.map((target) => {
    const escapedBranch = escapeGithubExpressionString(target.branch)
    return [
      `      - name: Deploy to Cloudflare (${target.branch})`,
      `        if: github.ref == 'refs/heads/${escapedBranch}'`,
      `        run: ${deployCommand} --env ${target.environmentName}`,
    ].join('\n')
  }).join('\n\n')
}
